# 3단계: 루빅스 큐브 구현하기

### ✅ 문제를 단순화하기

1. 반시계 방향 회전 1번은 시계 방향으로 3번과 같다.

2. 3차원 큐브에서 회전하는 면이 위가 향하도록 했을 때,인접 4면을 바라보면 왼쪽으로 회전한다. 즉 1, 2단계에서 사용했던 `rotL` 함수를 사용할 수 있다.

<br/>

---

## 12월 13일 기준

원하는대로 구현을 아직 못 해서 생각했던 문제 해결 과정을 업로드합니다. 😔

1. 문제에서 주어진 [참고 사이트](https://cube3x3.com/%ED%81%90%EB%B8%8C%EB%A5%BC-%EB%A7%9E%EC%B6%94%EB%8A%94-%EB%B0%A9/#notation)를 보고 큐브의 초기 상태를 U 흰색, F 초록색, R 빨간색, L 주황색, B 파란색, D 노란색 으로 설정했습니다. (문제에 주어진 큐브의 초기 상태와 약간 다름) 큐브를 직접 사서 보니 이 설정대로 해야 큐브를 직접 보면서 할 수 있을 것 같아서요.

2. 처음에는 1, 2단계와 연관시켜 규칙을 찾다가, 돌리는 면의 인접 4면을 보면 12개의 글자가 3개씩 밀어진다는 것을 발견했습니다. 시계방향이라고 했을 때 인접 4면 또한 오른쪽으로 밀어내는 것으로 생각했습니다.

![코드스쿼드 코코아-89](https://user-images.githubusercontent.com/60209518/102012008-473f2080-3d8b-11eb-8d75-b20cb9d41832.jpg)

3. 이후에 2-3단계의 연관성을 발견하고 왼쪽 회전 (`rotL`) 으로 모든 것을 구현하기로 방법을 바꿨습니다. 제 생각에 2-3단계의 연관성은 시계 방향 회전이 왼쪽 회전이라는 것인데요, 글로 설명하기는 조금 어려우니 아래 사진을 봐주시길 바랍니다.

![IMG_2288](https://user-images.githubusercontent.com/60209518/102012399-66d74880-3d8d-11eb-8837-c21ea7254980.jpg)

4. 여기까지 생각을 하니 3단계 문제를 아주 쉽게 풀 수 있을 것 같았습니다.

    4-1. 시계 방향 회전 시

    - 명령어에 해당하는 면을 시계방향 회전
    - 인접한 4 배열을 뽑아 새로운 배열로 만든 뒤 `rotL`
    - 왼쪽 회전한 결과를 각 4면에 다시 넣어줌

    4-2. 반시계 방향 회전 시

    - 명령어에 해당하는 면을 시계방향 3번 회전
    - 인접한 4 배열을 뽑아 새로운 배열로 만든 뒤 `rotL` 3번
    - 왼쪽 3번 회전한 결과를 각 4면에 다시 넣어줌

    즉, 명령어에 해당하는 면은 그 면대로 시계방향 90도 회전시키고, 인접 4면은 `1. 꺼낸다. 2. 돌린다. 3. 다시 넣는다.` 로 요약할 수 있었습니다.

5. 하지만 문제가 생겼습니다. U 명령어를 실행할 때는 인접 4면에서 행을 뽑을 때 인덱스가 0, 1, 2로 다 같았으나, 다른 명령어를 실행할 때는 행/열을 뽑을 때 인덱스가 거꾸로 되는 경우가 발생했습니다. 예를 들어 R 명령어 실행 시 다음과 같은 경우가 발생합니다.

![IMG_2289](https://user-images.githubusercontent.com/60209518/102012738-81aabc80-3d8f-11eb-8555-fd3ea8c8df26.jpg)

      (0,0)은 전개도를 기준으로 각 면의 왼쪽 맨 위입니다.
      A, B, C는 인덱스가 0, 1, 2로 가는 반면,

![IMG_2290](https://user-images.githubusercontent.com/60209518/102012819-cfbfc000-3d8f-11eb-9275-08d973ecbadf.jpg)

      D는 인덱스가 2, 1, 0으로 거꾸로 된 것을 알 수 있습니다. 즉, 인접 4면의 배열을 새로 만들 때 인덱스가 거꾸로 된 면은 한 번 뒤집고, 왼쪽 회전을 시킨 뒤 다시 뒤집어서 해당 면에 다시 넣어줘야 합니다. 이것을 정리한 것이 다음 이미지입니다.

![IMG_30FCB5610261-1](https://user-images.githubusercontent.com/60209518/102012883-17dee280-3d90-11eb-84aa-2bc5234c11c9.jpeg)

    D를 포함하여 빨간색으로 표시된 것들이 reverse가 필요한 경우들입니다. 절반에 해당하는 수입니다. 또한, 각 명령어마다 인덱스가 뒤집히는 면도 다 달라서 하나의 함수로 일반화할 수도 없었습니다. 여기까지 오니 어쩔 수 없이 각 명령어마다 뒤집어야 할 부분을 다 써줘야겠다는 생각이 들었고, 그것을 구현해보려는 중에 시간이 부족하여 끝까지 구현해보지 못했습니다.

    현재 코드에서는 배열의 참조가 잘못 된 건지 아직 문제를 찾지 못했지만 명령어를 제대로 수행하지 못하고 있습니다.

6. 그 밖에 생각해본 방법은 전개도 상에서 인접 4면이 이동하는 것을 일자로 나열, 즉 인접 4면을 적당히 회전시켜 1단계처럼 글자 이동으로 구현 후 다시 돌려놓는 것입니다. 예를 들어 F 명령어 실행 시 다음과 같이 면을 돌립니다.

![IMG_E60B116FA7FE-1](https://user-images.githubusercontent.com/60209518/102013056-0813ce00-3d91-11eb-80ba-b024e02b5bb0.jpeg)

---

1, 2단계처럼 간단하게 풀고자 엄청!! 고민을 많이 했는데 지금까지 생각해본 결과, 각각의 경우에 따라서 지정을 해줘야 하는 것 같습니다. 제출 이후에 끝까지 구현해볼 생각입니다!
